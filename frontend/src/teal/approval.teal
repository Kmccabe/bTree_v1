#pragma version 8

// Creation branch
txn ApplicationID
int 0
==
bnz create

// Runtime branch (support NoOp + OptIn)
txn OnCompletion
int NoOp
==
bnz noop

txn OnCompletion
int OptIn
==
bnz optin

// Reject everything else
err

create:
  // Expect 3 creation args: E, m, UNIT
  txn NumAppArgs
  int 3
  ==
  assert

  byte "E"
  txn ApplicationArgs 0
  btoi
  app_global_put

  byte "m"
  txn ApplicationArgs 1
  btoi
  app_global_put

  byte "UNIT"
  txn ApplicationArgs 2
  btoi
  app_global_put

  byte "phase"
  int 1
  app_global_put

  int 1
  return

// -------------------------
noop:
  // At least a method name
  txn NumAppArgs
  int 1
  >=
  assert

  // method dispatch
  txn ApplicationArgs 0
  byte "set_phase"
  ==
  bnz set_phase

  txn ApplicationArgs 0
  byte "invest"
  ==
  bnz invest

  txn ApplicationArgs 0
  byte "return"
  ==
  bnz retpath

  txn ApplicationArgs 0
  byte "sweep"
  ==
  bnz sweep

  err

// Accept opt-in to allocate local state
optin:
  int 1
  return

// -------------------------
// Admin: set_phase(p) where p in [1..4]
// Only the app creator may call
set_phase:
  // creator gate
  txn Sender
  global CreatorAddress
  ==
  assert

  // ["set_phase", p]
  txn NumAppArgs
  int 2
  ==
  assert

  txn ApplicationArgs 1
  btoi
  store 10        // p

  // bounds 1..4
  load 10
  int 1
  >=
  assert
  load 10
  int 4
  <=
  assert

  byte "phase"
  load 10
  app_global_put

  int 1
  return

// ---- invest(s): phase==2, group[0]=pay s caller->app, group[1]=this call
invest:
  // phase gate
  byte "phase"
  app_global_get
  int 2
  ==
  assert

  // args: ["invest", s]
  txn NumAppArgs
  int 2
  ==
  assert
  txn ApplicationArgs 1
  btoi
  store 0                    // s

  // bounds / unit checks
  byte "E"
  app_global_get
  store 1                    // E
  byte "UNIT"
  app_global_get
  store 2                    // UNIT

  load 0
  int 0
  >=
  assert
  load 0
  load 1
  <=
  assert
  load 0
  load 2
  %
  int 0
  ==
  assert

  // subject must be opted-in
  txn Sender
  global CurrentApplicationID
  app_opted_in
  assert

  // not already invested: local "done" == 0 (read sender-local)
  txn Sender
  byte "done"
  app_local_get
  int 0
  ==
  assert

  // group shape: size 2, this is index 1
  global GroupSize
  int 2
  ==
  assert
  txn GroupIndex
  int 1
  ==
  assert

  // gtxn[0] must be payment s from caller -> app, no rekey/close
  gtxn 0 TypeEnum
  int pay
  ==
  assert
  gtxn 0 Sender
  txn Sender
  ==
  assert
  gtxn 0 Receiver
  global CurrentApplicationAddress
  ==
  assert
  gtxn 0 RekeyTo
  global ZeroAddress
  ==
  assert
  gtxn 0 CloseRemainderTo
  global ZeroAddress
  ==
  assert
  gtxn 0 Amount
  load 0
  ==
  assert

  // write local s & done to sender-local state
  txn Sender
  byte "s"
  load 0
  app_local_put

  // compute t = 3 * s and persist to local (mirror) and global
  // assume s in scratch slot 0; use adds to avoid mul opcode
  load 0
  dup
  dup
  +                   // s + s
  +                   // (s+s) + s = 3*s
  store 6             // keep t in scratch 6
  // local mirror: sender.t = 3*s
  txn Sender
  byte "t"
  load 6
  app_local_put
  // global: t = 3*s
  byte "t"
  load 6
  app_global_put

  // persist S1 address globally for Return path
  txn Sender
  byte "s1"
  swap
  app_global_put

  txn Sender
  byte "done"
  int 1
  app_local_put

  // delta = E - s
  load 1
  load 0
  -
  store 5

  // inner refund (E - s) to caller if > 0, Fee=0 (outer covers)
  load 5
  int 0
  >
  bnz do_refund
  b invest_end

do_refund:
  itxn_begin
  int pay
  itxn_field TypeEnum
  txn Sender
  itxn_field Receiver
  load 5
  itxn_field Amount
  int 0
  itxn_field Fee
  itxn_submit

invest_end:
  int 1
  return

// -------------------------
// CASE: "sweep" (Phase 3, creator-only)
sweep:
  // Guard phase == 3
  byte "phase"
  app_global_get
  int 3
  ==
  assert

  // creator-only
  global CreatorAddress
  txn Sender
  ==
  assert

  // not already swept: swept == 0
  byte "swept"
  app_global_get
  int 0
  ==
  assert

  // app_liquid = balance(app) - min_balance(app)
  global CurrentApplicationAddress
  dup
  balance
  swap
  min_balance
  -
  store 20

  // if app_liquid > 0, inner pay to creator
  load 20
  int 0
  >
  bnz do_sweep
  b end_sweep

do_sweep:
  itxn_begin
  int pay
  itxn_field TypeEnum
  load 20
  itxn_field Amount
  global CreatorAddress
  itxn_field Receiver
  itxn_submit

end_sweep:
  // mark swept = 1
  byte "swept"
  int 1
  app_global_put

  int 1
  return

// -------------------------
// CASE: "return" (Subject 2)
// Pre-req: t in global from Invest
// args: [ "return", r:uint ]
retpath:
  // Guard phase == 2
  byte "phase"
  app_global_get
  int 2
  ==
  assert

  // t > 0
  byte "t"
  app_global_get
  dup
  store 10              // t in scratch[10]
  int 0
  >
  assert

  // not already returned: ret == 0
  byte "ret"
  app_global_get
  int 0
  ==
  assert

  // r = arg[1] (uint)
  txna ApplicationArgs 1
  btoi
  store 11              // r

  // 0 <= r <= t
  load 11
  int 0
  >=
  assert
  load 11
  load 10
  <=
  assert

  // Solvency: app_liquid >= t
  global CurrentApplicationAddress
  dup
  balance
  swap
  min_balance
  -
  load 10              // t
  >=
  assert

  // itxn #1: pay r -> S1
  byte "s1"
  app_global_get         // push S1 addr bytes and keep on stack for Receiver
  itxn_begin
  int pay
  itxn_field TypeEnum
  load 11
  itxn_field Amount
  itxn_field Receiver
  itxn_submit

  // itxn #2: pay (t - r) -> Sender (S2)
  itxn_begin
  int pay
  itxn_field TypeEnum
  load 10
  load 11
  -
  itxn_field Amount
  txn Sender
  itxn_field Receiver
  itxn_submit

  // mark returned
  byte "ret"
  int 1
  app_global_put

  int 1
  return
