#pragma version 8

// Creation branch
txn ApplicationID
int 0
==
bnz create

// Runtime branch (only NoOp supported so far)
txn OnCompletion
int NoOp
==
bnz noop

// Reject everything else
err

create:
  // Expect 3 creation args: E, m, UNIT
  txn NumAppArgs
  int 3
  ==
  assert

  byte "E"
  txn ApplicationArgs 0
  btoi
  app_global_put

  byte "m"
  txn ApplicationArgs 1
  btoi
  app_global_put

  byte "UNIT"
  txn ApplicationArgs 2
  btoi
  app_global_put

  byte "phase"
  int 1
  app_global_put

  int 1
  return

// -------------------------
noop:
  // At least a method name
  txn NumAppArgs
  int 1
  >=
  assert

  // method dispatch
  txn ApplicationArgs 0
  byte "set_phase"
  ==
  bnz set_phase

  txn ApplicationArgs 0
  byte "invest"
  ==
  bnz invest

  err

// -------------------------
// Admin: set_phase(p) where p in [1..4]
// Only the app creator may call
set_phase:
  // creator gate
  txn Sender
  global CreatorAddress
  ==
  assert

  // ["set_phase", p]
  txn NumAppArgs
  int 2
  ==
  assert

  txn ApplicationArgs 1
  btoi
  store 10        // p

  // bounds 1..4
  load 10
  int 1
  >=
  assert
  load 10
  int 4
  <=
  assert

  byte "phase"
  load 10
  app_global_put

  int 1
  return

// ---- invest(s): phase==2, group[0]=pay s caller->app, group[1]=this call
invest:
  // phase gate
  byte "phase"
  app_global_get
  int 2
  ==
  assert

  // args: ["invest", s]
  txn NumAppArgs
  int 2
  ==
  assert
  txn ApplicationArgs 1
  btoi
  store 0                    // s

  // bounds / unit checks
  byte "E"
  app_global_get
  store 1                    // E
  byte "UNIT"
  app_global_get
  store 2                    // UNIT

  load 0
  int 0
  >=
  assert
  load 0
  load 1
  <=
  assert
  load 0
  load 2
  %
  int 0
  ==
  assert

  // subject must be opted-in
  txn Sender
  global CurrentApplicationID
  app_opted_in
  assert

  // not already invested: local "done" == 0
  byte "done"
  app_local_get
  int 0
  ==
  assert

  // group shape: size 2, this is index 1
  global GroupSize
  int 2
  ==
  assert
  txn GroupIndex
  int 1
  ==
  assert

  // gtxn[0] must be payment s from caller -> app, no rekey/close
  gtxn 0 TypeEnum
  int pay
  ==
  assert
  gtxn 0 Sender
  txn Sender
  ==
  assert
  gtxn 0 Receiver
  global CurrentApplicationAddress
  ==
  assert
  gtxn 0 RekeyTo
  global ZeroAddress
  ==
  assert
  gtxn 0 CloseRemainderTo
  global ZeroAddress
  ==
  assert
  gtxn 0 Amount
  load 0
  ==
  assert

  // write local s & done
  byte "s"
  load 0
  app_local_put
  byte "done"
  int 1
  app_local_put

  // delta = E - s
  load 1
  load 0
  -
  store 5

  // inner refund (E - s) to caller if > 0, Fee=0 (outer covers)
  load 5
  int 0
  >
  bnz do_refund
  b invest_end

do_refund:
  itxn_begin
  int pay
  itxn_field TypeEnum
  txn Sender
  itxn_field Receiver
  load 5
  itxn_field Amount
  int 0
  itxn_field Fee
  itxn_submit

invest_end:
  int 1
  return
