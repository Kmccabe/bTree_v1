// Trust Game v1 – Single-Pair Invest/Return
#pragma version 8

// Phases (globals.phase): 0=Registration, 1=Invest, 2=Return, 3=Done
// Globals (uint unless noted):
//   UNIT, m, E1, E2, s, t, phase, invested, ret, swept
//   s1 (bytes), s2 (bytes)

// Creation branch
txn ApplicationID
int 0
==
bnz create

// Runtime branch (support NoOp + OptIn)
txn OnCompletion
int NoOp
==
bnz noop

txn OnCompletion
int DeleteApplication
==
bnz delapp

txn OnCompletion
int OptIn
==
bnz optin

// Reject everything else
err

// Creator-only DeleteApplication
delapp:
  global CreatorAddress
  txn Sender
  ==
  assert
  int 1
  return

create:
  // Expect 4 creation args: E1, E2, m, UNIT
  txn NumAppArgs
  int 4
  ==
  assert

  // E1 (display only)
  byte "E1"
  txn ApplicationArgs 0
  btoi
  app_global_put

  // E2 (paid to S2 at Return)
  byte "E2"
  txn ApplicationArgs 1
  btoi
  app_global_put

  // m (multiplier)
  byte "m"
  txn ApplicationArgs 2
  btoi
  app_global_put

  // UNIT (granularity)
  byte "UNIT"
  txn ApplicationArgs 3
  btoi
  app_global_put

  // phase = Registration(0)
  byte "phase"
  int 0
  app_global_put

  // invested=0, ret=0, t=0, s=0, swept=0
  byte "invested"
  int 0
  app_global_put
  byte "ret"
  int 0
  app_global_put
  byte "t"
  int 0
  app_global_put
  byte "s"
  int 0
  app_global_put
  byte "swept"
  int 0
  app_global_put

  int 1
  return

// -------------------------
noop:
  // At least a method name
  txn NumAppArgs
  int 1
  >=
  assert

  // method dispatch
  txn ApplicationArgs 0
  byte "set_phase"
  ==
  bnz set_phase

  txn ApplicationArgs 0
  byte "invest"
  ==
  bnz invest

  txn ApplicationArgs 0
  byte "return"
  ==
  bnz retpath

  txn ApplicationArgs 0
  byte "sweep"
  ==
  bnz sweep

  txn ApplicationArgs 0
  byte "registerExperiment"
  ==
  bnz reg_exp

  err

// -------------------------
// Opt-In: latch S1 and S2 (first two opt-ins). Reject further.
optin:
  // Gate: experiment must be registered and phase must be 0
  byte "exp_registered"
  app_global_get
  int 1
  ==
  assert
  byte "phase"
  app_global_get
  int 0
  ==
  assert
  // Robust existence checks using app_global_get_ex to avoid
  // type-mismatch when keys are unset (unset -> uint 0).
  // If s1 not set -> set to sender. Else if s2 not set and sender != s1 -> set s2. Else reject.

  // Check s1 existence
  global CurrentApplicationID
  byte "s1"
  app_global_get_ex        // stack: value, exists
  bz set_s1                // if not exists -> set s1
  pop                      // discard value

  // s1 exists; now check s2 existence
  global CurrentApplicationID
  byte "s2"
  app_global_get_ex        // stack: value, exists
  bz maybe_set_s2          // if not exists -> set s2
  pop                      // discard value

  // Else: both set -> reject further opt-ins
  err

set_s1:
  txn Sender
  byte "s1"
  swap
  app_global_put
  int 1
  return

// -------------------------
// Admin: registerExperiment(raw32 params_hash, uint n_needed, bytes contract_uri)
// Args: ["registerExperiment", arg1, arg2, arg3]
reg_exp:
  // Creator-only
  txn Sender
  global CreatorAddress
  ==
  assert
  // Expect 4 args total
  txn NumAppArgs
  int 4
  ==
  assert
  // Not already registered
  byte "exp_registered"
  app_global_get
  int 0
  ==
  assert
  // params_hash length must be 32
  txna ApplicationArgs 1
  len
  int 32
  ==
  assert
  // Write globals
  byte "exp_registered"
  int 1
  app_global_put
  byte "exp_ts"
  global LatestTimestamp
  app_global_put
  byte "n_needed"
  txna ApplicationArgs 2
  btoi
  app_global_put
  byte "params_hash"
  txna ApplicationArgs 1
  app_global_put
  byte "contract_uri"
  txna ApplicationArgs 3
  app_global_put
  int 1
  return

maybe_set_s2:
  // Ensure sender != s1 (compare against s1 fetched bytes)
  txn Sender
  byte "s1"
  app_global_get
  ==
  // if equal -> reject
  bnz opt_reject
  // else set s2
  txn Sender
  byte "s2"
  swap
  app_global_put
  int 1
  return

opt_reject:
  err

// -------------------------
// Admin: set_phase(p) where p in [0..3]; only creator
set_phase:
  txn Sender
  global CreatorAddress
  ==
  assert
  txn NumAppArgs
  int 2
  ==
  assert
  txn ApplicationArgs 1
  btoi
  store 10        // p
  // bounds 0..3
  load 10
  int 0
  >=
  assert
  load 10
  int 3
  <=
  assert
  byte "phase"
  load 10
  app_global_put
  int 1
  return

// -------------------------
// invest(s):
// - allowed if phase == 1 (Invest) OR (phase == 0 and both S1,S2 set)
// - grouped with Payment s from S1 -> app (gtxn[0]) and this AppCall (gtxn[1])
invest:
  // sender must be S1; use get_ex to avoid type mismatch when unset
  global CurrentApplicationID
  byte "s1"
  app_global_get_ex        // value, exists
  assert                   // must exist
  pop                      // drop value
  // And equal to Sender
  txn Sender
  // Re-fetch s1 as bytes for a stable type in the equality
  byte "s1"
  app_global_get
  ==
  assert

  // phase check
  byte "phase"
  app_global_get
  store 20              // ph
  // if ph == 1 → ok
  load 20
  int 1
  ==
  bnz invest_args
  // else if ph == 0 ensure both s1 and s2 set
  load 20
  int 0
  ==
  bz invest_fail
  // s1 existence already checked above; check s2 exists via get_ex
  global CurrentApplicationID
  byte "s2"
  app_global_get_ex        // value, exists
  assert                   // must exist
  pop                      // drop value

invest_args:
  // args: ["invest", s]
  txn NumAppArgs
  int 2
  ==
  assert
  txn ApplicationArgs 1
  btoi
  store 0                    // s

  // bounds / unit checks
  byte "E1"
  app_global_get
  store 1                    // E1
  byte "UNIT"
  app_global_get
  store 2                    // UNIT

  load 0
  int 0
  >=
  assert
  load 0
  load 1
  <=
  assert
  load 0
  load 2
  %
  int 0
  ==
  assert

  // subject must be opted-in
  txn Sender
  global CurrentApplicationID
  app_opted_in
  assert

  // not already invested: global invested == 0 and local done == 0
  byte "invested"
  app_global_get
  int 0
  ==
  assert
  txn Sender
  byte "done"
  app_local_get
  int 0
  ==
  assert

  // group shape: size 2, this is index 1; payment at 0
  global GroupSize
  int 2
  ==
  assert
  txn GroupIndex
  int 1
  ==
  assert

  // gtxn[0] must be payment s from S1 -> app, no rekey/close
  gtxn 0 TypeEnum
  int pay
  ==
  assert
  gtxn 0 Sender
  byte "s1"
  app_global_get
  ==
  assert
  gtxn 0 Receiver
  global CurrentApplicationAddress
  ==
  assert
  gtxn 0 RekeyTo
  global ZeroAddress
  ==
  assert
  gtxn 0 CloseRemainderTo
  global ZeroAddress
  ==
  assert
  gtxn 0 Amount
  load 0
  ==
  assert

  // refund to S1: amount = E1 - s (subject receives leftover of endowment)
  byte "E1"
  app_global_get
  load 0
  -
  store 7                 // refund = E1 - s
  // Solvency: (balance - min_balance) >= refund
  global CurrentApplicationAddress
  dup
  balance
  swap
  min_balance
  -
  load 7
  >=
  assert
  // If refund > 0, inner payment to S1
  load 7
  int 0
  >
  bz skip_refund
  itxn_begin
  int pay
  itxn_field TypeEnum
  load 7
  itxn_field Amount
  byte "s1"
  app_global_get
  itxn_field Receiver
  itxn_submit
skip_refund:

  // write local s & done to S1 local state
  txn Sender
  byte "s"
  load 0
  app_local_put
  txn Sender
  byte "done"
  int 1
  app_local_put

  // compute t = m * s and persist global/local mirror
  byte "m"
  app_global_get
  load 0
  *
  store 6                 // t
  byte "t"
  load 6
  app_global_put
  byte "s"
  load 0
  app_global_put

  // set invested=1, phase=Return(2)
  byte "invested"
  int 1
  app_global_put
  byte "phase"
  int 2
  app_global_put

  int 1
  return

invest_fail:
  err

// -------------------------
// CASE: "sweep" (Phase 3, creator-only)
sweep:
  // Guard phase == 3
  byte "phase"
  app_global_get
  int 3
  ==
  assert

  // creator-only
  global CreatorAddress
  txn Sender
  ==
  assert

  // not already swept: swept == 0
  byte "swept"
  app_global_get
  int 0
  ==
  assert

  // app_liquid = balance(app) - min_balance(app)
  global CurrentApplicationAddress
  dup
  balance
  swap
  min_balance
  -
  store 20

  // if app_liquid > 0, inner pay to creator
  load 20
  int 0
  >
  bnz do_sweep
  b end_sweep

do_sweep:
  itxn_begin
  int pay
  itxn_field TypeEnum
  load 20
  itxn_field Amount
  global CreatorAddress
  itxn_field Receiver
  itxn_submit

end_sweep:
  // mark swept = 1
  byte "swept"
  int 1
  app_global_put

  int 1
  return

// -------------------------
// CASE: "return" (Subject 2)
// args: [ "return", r:uint ]
retpath:
  // Guard phase == 2
  byte "phase"
  app_global_get
  int 2
  ==
  assert

  // sender must be S2; assert s2 exists then compare as bytes
  global CurrentApplicationID
  byte "s2"
  app_global_get_ex      // value, exists
  assert                 // must exist
  pop                    // drop value
  txn Sender
  byte "s2"
  app_global_get
  ==
  assert

  // not already returned: ret == 0
  byte "ret"
  app_global_get
  int 0
  ==
  assert

  // t from global
  byte "t"
  app_global_get
  store 10              // t

  // r = arg[1] (uint)
  txna ApplicationArgs 1
  btoi
  store 11              // r

  // UNIT and E2
  byte "UNIT"
  app_global_get
  store 12              // UNIT
  byte "E2"
  app_global_get
  store 13              // E2

  // enforce r % UNIT == 0 and 0 <= r <= t
  load 11
  load 12
  %
  int 0
  ==
  assert
  load 11
  int 0
  >=
  assert
  load 11
  load 10
  <=
  assert

  // Solvency: (balance - min_balance) >= (t + E2)
  global CurrentApplicationAddress
  dup
  balance
  swap
  min_balance
  -
  load 10
  load 13
  +
  >=
  assert

  // itxn #1: pay r -> S1 (assert s1 exists)
  global CurrentApplicationID
  byte "s1"
  app_global_get_ex      // value, exists
  assert                 // must exist
  pop                    // drop value
  // Use a fresh fetch to get S1 address bytes for Receiver field
  byte "s1"
  app_global_get
  itxn_begin
  int pay
  itxn_field TypeEnum
  load 11
  itxn_field Amount
  itxn_field Receiver
  itxn_submit

  // itxn #2: pay (t - r + E2) -> Sender (S2)
  itxn_begin
  int pay
  itxn_field TypeEnum
  load 10
  load 11
  -
  load 13
  +
  itxn_field Amount
  txn Sender
  itxn_field Receiver
  itxn_submit

  // Effects: ret = 1, phase = Done(3)
  byte "ret"
  int 1
  app_global_put
  byte "phase"
  int 3
  app_global_put

  int 1
  return
