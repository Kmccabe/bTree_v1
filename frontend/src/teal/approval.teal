// Trust Game v1 â€“ Single-Pair Invest/Return
#pragma version 8

// Phases (globals.phase): 0=Registration, 1=Invest, 2=Return, 3=Done
// Globals (uint unless noted):
//   UNIT, m, E1, E2, s, t, phase, invested, ret, swept
//   s1 (bytes), s2 (bytes)

// Creation branch
txn ApplicationID
int 0
==
bnz create

// Runtime branch (support NoOp)
txn OnCompletion
int NoOp
==
bnz noop

txn OnCompletion
int DeleteApplication
==
bnz delapp

// No subject opt-in; reject OptIn elsewhere

// Reject everything else
err

// Creator-only DeleteApplication
delapp:
  global CreatorAddress
  txn Sender
  ==
  assert
  int 1
  return

create:
  // Expect 4 creation args: E1, E2, m, UNIT
  txn NumAppArgs
  int 4
  ==
  assert

  // E1 (display only)
  byte "E1"
  txn ApplicationArgs 0
  btoi
  app_global_put

  // E2 (paid to S2 at Return)
  byte "E2"
  txn ApplicationArgs 1
  btoi
  app_global_put

  // m (multiplier)
  byte "m"
  txn ApplicationArgs 2
  btoi
  app_global_put

  // UNIT (granularity)
  byte "UNIT"
  txn ApplicationArgs 3
  btoi
  app_global_put

  // phase = Registration(0)
  byte "phase"
  int 0
  app_global_put

  // invested=0, ret=0, t=0, s=0, swept=0
  byte "invested"
  int 0
  app_global_put
  byte "ret"
  int 0
  app_global_put
  byte "t"
  int 0
  app_global_put
  byte "s"
  int 0
  app_global_put
  byte "swept"
  int 0
  app_global_put
  // s1_addr / s2_addr unset initially; creator will set via setPair

  int 1
  return

// -------------------------
noop:
  // At least a method name
  txn NumAppArgs
  int 1
  >=
  assert

  // method dispatch
  txn ApplicationArgs 0
  byte "set_phase"
  ==
  bnz set_phase

  txn ApplicationArgs 0
  byte "invest"
  ==
  bnz invest

  txn ApplicationArgs 0
  byte "return"
  ==
  bnz retpath

  txn ApplicationArgs 0
  byte "sweep"
  ==
  bnz sweep

  txn ApplicationArgs 0
  byte "setPair"
  ==
  bnz set_pair

  err

// (No OptIn handler)

// -------------------------
// Admin: set_phase(p) where p in [0..3]; only creator
set_phase:
  txn Sender
  global CreatorAddress
  ==
  assert
  txn NumAppArgs
  int 2
  ==
  assert
  txn ApplicationArgs 1
  btoi
  store 10        // p
  // bounds 0..3
  load 10
  int 0
  >=
  assert
  load 10
  int 3
  <=
  assert
  byte "phase"
  load 10
  app_global_put
  int 1
  return

// -------------------------
// Admin: setPair(s1_raw32, s2_raw32) one-time
set_pair:
  // Creator-only
  txn Sender
  global CreatorAddress
  ==
  assert
  // Expect 3 args total: ["setPair", s1_raw32, s2_raw32]
  txn NumAppArgs
  int 3
  ==
  assert
  // arg1 and arg2 must be 32 bytes
  txna ApplicationArgs 1
  len
  int 32
  ==
  assert
  txna ApplicationArgs 2
  len
  int 32
  ==
  assert
  // Ensure not already set
  global CurrentApplicationID
  byte "s1_addr"
  app_global_get_ex   // value, exists
  pop
  !
  assert
  global CurrentApplicationID
  byte "s2_addr"
  app_global_get_ex   // value, exists
  pop
  !
  assert
  // Set globals
  byte "s1_addr"
  txna ApplicationArgs 1
  app_global_put
  byte "s2_addr"
  txna ApplicationArgs 2
  app_global_put
  int 1
  return

// -------------------------
// invest(s): grouped with Payment s from S1 -> app (gtxn[0]) and this AppCall (gtxn[1])
invest:
  // sender must be S1 (stored in s1_addr)
  global CurrentApplicationID
  byte "s1_addr"
  app_global_get_ex        // value, exists
  assert
  pop
  txn Sender
  byte "s1_addr"
  app_global_get
  ==
  assert

  // phase must be 2
  byte "phase"
  app_global_get
  int 2
  ==
  assert

invest_args:
  // args: ["invest", s]
  txn NumAppArgs
  int 2
  ==
  assert
  txn ApplicationArgs 1
  btoi
  store 0                    // s

  // bounds / unit checks
  byte "E1"
  app_global_get
  store 1                    // E1
  byte "UNIT"
  app_global_get
  store 2                    // UNIT

  load 0
  int 0
  >=
  assert
  load 0
  load 1
  <=
  assert
  load 0
  load 2
  %
  int 0
  ==
  assert

  // not already invested: global invested == 0
  byte "invested"
  app_global_get
  int 0
  ==
  assert

  // group shape: size 2, this is index 1; payment at 0
  global GroupSize
  int 2
  ==
  assert
  txn GroupIndex
  int 1
  ==
  assert

  // gtxn[0] must be payment s from S1 -> app, no rekey/close
  gtxn 0 TypeEnum
  int pay
  ==
  assert
  gtxn 0 Sender
  byte "s1_addr"
  app_global_get
  ==
  assert
  gtxn 0 Receiver
  global CurrentApplicationAddress
  ==
  assert
  gtxn 0 RekeyTo
  global ZeroAddress
  ==
  assert
  gtxn 0 CloseRemainderTo
  global ZeroAddress
  ==
  assert
  gtxn 0 Amount
  load 0
  ==
  assert

  // refund to S1: amount = E1 - s (subject receives leftover of endowment)
  byte "E1"
  app_global_get
  load 0
  -
  store 7                 // refund = E1 - s
  // Solvency: (balance - min_balance) >= refund
  global CurrentApplicationAddress
  dup
  balance
  swap
  min_balance
  -
  load 7
  >=
  assert
  // If refund > 0, inner payment to S1
  load 7
  int 0
  >
  bz skip_refund
  itxn_begin
  int pay
  itxn_field TypeEnum
  load 7
  itxn_field Amount
  byte "s1_addr"
  app_global_get
  itxn_field Receiver
  itxn_submit
skip_refund:

  // (no local state)

  // compute t = m * s and persist global/local mirror
  byte "m"
  app_global_get
  load 0
  *
  store 6                 // t
  byte "t"
  load 6
  app_global_put
  byte "s"
  load 0
  app_global_put

  // set invested=1, advance phase to Return(3)
  byte "invested"
  int 1
  app_global_put
  byte "phase"
  int 3
  app_global_put

  int 1
  return

// (no alternate Invest branch)

// -------------------------
// CASE: "sweep" (Phase 3, creator-only)
sweep:
  // Guard phase == 3
  byte "phase"
  app_global_get
  int 3
  ==
  assert

  // creator-only
  global CreatorAddress
  txn Sender
  ==
  assert

  // not already swept: swept == 0
  byte "swept"
  app_global_get
  int 0
  ==
  assert

  // app_liquid = balance(app) - min_balance(app)
  global CurrentApplicationAddress
  dup
  balance
  swap
  min_balance
  -
  store 20

  // if app_liquid > 0, inner pay to creator
  load 20
  int 0
  >
  bnz do_sweep
  b end_sweep

do_sweep:
  itxn_begin
  int pay
  itxn_field TypeEnum
  load 20
  itxn_field Amount
  global CreatorAddress
  itxn_field Receiver
  itxn_submit

end_sweep:
  // mark swept = 1
  byte "swept"
  int 1
  app_global_put

  int 1
  return

// -------------------------
// CASE: "return" (Subject 2)
// args: [ "return", r:uint ]
retpath:
  // Guard phase == 3
  byte "phase"
  app_global_get
  int 3
  ==
  assert

  // sender must be S2; assert s2_addr exists then compare as bytes
  global CurrentApplicationID
  byte "s2_addr"
  app_global_get_ex      // value, exists
  assert                 // must exist
  pop                    // drop value
  txn Sender
  byte "s2_addr"
  app_global_get
  ==
  assert

  // not already returned: ret == 0
  byte "ret"
  app_global_get
  int 0
  ==
  assert

  // t from global
  byte "t"
  app_global_get
  store 10              // t

  // r = arg[1] (uint)
  txna ApplicationArgs 1
  btoi
  store 11              // r

  // UNIT and E2
  byte "UNIT"
  app_global_get
  store 12              // UNIT
  byte "E2"
  app_global_get
  store 13              // E2

  // enforce r % UNIT == 0 and 0 <= r <= t
  load 11
  load 12
  %
  int 0
  ==
  assert
  load 11
  int 0
  >=
  assert
  load 11
  load 10
  <=
  assert

  // Solvency: (balance - min_balance) >= (t + E2)
  global CurrentApplicationAddress
  dup
  balance
  swap
  min_balance
  -
  load 10
  load 13
  +
  >=
  assert

  // itxn #1: pay r -> S1 (assert s1_addr exists)
  global CurrentApplicationID
  byte "s1_addr"
  app_global_get_ex      // value, exists
  assert                 // must exist
  pop                    // drop value
  // Use a fresh fetch to get S1 address bytes for Receiver field
  byte "s1_addr"
  app_global_get
  itxn_begin
  int pay
  itxn_field TypeEnum
  load 11
  itxn_field Amount
  itxn_field Receiver
  itxn_submit

  // itxn #2: pay (t - r + E2) -> Sender (S2)
  itxn_begin
  int pay
  itxn_field TypeEnum
  load 10
  load 11
  -
  load 13
  +
  itxn_field Amount
  txn Sender
  itxn_field Receiver
  itxn_submit

  // Effects: ret = 1, phase = Done(3)
  byte "ret"
  int 1
  app_global_put
  byte "phase"
  int 3
  app_global_put

  int 1
  return
